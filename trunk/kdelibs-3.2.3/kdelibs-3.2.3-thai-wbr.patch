diff -uNr kdelibs-3.2.3.org/debian/changelog kdelibs-3.2.3/debian/changelog
--- kdelibs-3.2.3.org/debian/changelog	2004-06-20 14:36:21.000000000 +0900
+++ kdelibs-3.2.3/debian/changelog	2004-06-20 14:43:52.000000000 +0900
@@ -1,3 +1,10 @@
+kdelibs (4:3.2.3-2thai1) unstable; urgency=low
+
+  * Adding Thai word break support (using libthai) in KHTML
+    (see http://linux.thai.net/Members/ott/qt/)
+
+ -- Pattara Kiatisevi <ott@linux.thai.net>  Sat, 20 Jun 2004 14:43:00 +0900
+
 kdelibs (4:3.2.3-2) unstable; urgency=low
 
   * KDE_3_2_BRANCH Update.
diff -uNr kdelibs-3.2.3.org/khtml/khtml_factory.cpp kdelibs-3.2.3/khtml/khtml_factory.cpp
--- kdelibs-3.2.3.org/khtml/khtml_factory.cpp	2004-02-29 21:32:10.000000000 +0900
+++ kdelibs-3.2.3/khtml/khtml_factory.cpp	2004-06-20 14:40:27.000000000 +0900
@@ -25,6 +25,7 @@
 #include "css/cssstyleselector.h"
 #include "html/html_imageimpl.h"
 #include "rendering/render_style.h"
+#include "rendering/break_lines.h"
 #include "misc/loader.h"
 
 #include <kinstance.h>
@@ -94,6 +95,7 @@
         khtml::CSSStyleSelector::clear();
         khtml::RenderStyle::cleanup();
         khtml::Cache::clear();
+        khtml::cleanup_thaibreaks();
     }
     else
         deref();
diff -uNr kdelibs-3.2.3.org/khtml/rendering/break_lines.cpp kdelibs-3.2.3/khtml/rendering/break_lines.cpp
--- kdelibs-3.2.3.org/khtml/rendering/break_lines.cpp	2002-09-06 03:12:06.000000000 +0900
+++ kdelibs-3.2.3/khtml/rendering/break_lines.cpp	2004-06-20 14:41:48.000000000 +0900
@@ -1 +1,93 @@
 #include <break_lines.h>
+#include <klibloader.h>
+#include "qcstring.h"
+#include <qtextcodec.h>
+#include <qcleanuphandler.h>
+
+
+typedef int (*th_brk_def)(const char*, int[], int);
+static th_brk_def th_brk;
+
+namespace khtml {
+    struct ThaiCache
+    {
+        ThaiCache() {
+            string = 0;
+            allocated = 0x400;
+            wbrpos = (int *) malloc(allocated*sizeof(int));
+            numwbrpos = 0;
+            numisbreakable = 0x400;
+            isbreakable = (int *) malloc(numisbreakable*sizeof(int));
+        }
+        ~ThaiCache() {
+            free(wbrpos);
+            free(isbreakable);
+            library->unload();
+        }
+        const QChar *string;
+        int *wbrpos;
+        int *isbreakable;
+        unsigned int allocated;
+        unsigned int numwbrpos,numisbreakable;
+        KLibrary *library;
+    };
+    static ThaiCache *cache = 0;
+
+    void cleanup_thaibreaks()
+    {
+        delete cache;
+    }
+
+    bool isBreakableThai( const QChar *string, const int pos, const int len)
+    {
+        static QTextCodec *thaiCodec = QTextCodec::codecForMib(2259);
+
+        /* load libthai dynamically */
+	if (( !th_brk || !cache) && thaiCodec  ) {
+            KLibLoader *loader = KLibLoader::self();
+            KLibrary *lib = loader->library("libthai.so.0");
+            if (lib && lib->hasSymbol("th_brk")) {
+                th_brk = (th_brk_def) lib->symbol("th_brk");
+                cache = new ThaiCache;
+                cache->library = lib;
+            } else {
+                // indication that loading failed and we shouldn't try to load again
+                thaiCodec = 0;
+                if (lib)
+                    lib->unload();
+            }
+        }
+
+        if (!th_brk)
+            return true;
+
+        // build up string of thai chars
+        if ( string != cache->string ) {
+            //fprintf(stderr,"new string found (not in cache), calling libthai\n");
+            QCString cstr = thaiCodec->fromUnicode( QConstString(string,len).string());
+            //printf("About to call libthai::th_brk with str: %s, pos: %d",thaiCache->data(),pos);
+
+            cache->numwbrpos = th_brk(cstr.data(), cache->wbrpos, cache->allocated);
+            //fprintf(stderr,"libthai returns with value %d\n",numwbrpos);
+            if (cache->numwbrpos > cache->allocated) {
+                cache->allocated = cache->numwbrpos;
+                cache->wbrpos = (int *)realloc(cache->wbrpos, cache->allocated*sizeof(int));
+                cache->numwbrpos = th_brk(cstr.data(), cache->wbrpos, cache->allocated);
+            }
+	    if ( (unsigned int) len > cache->numisbreakable ) {
+		cache->numisbreakable=len;
+                cache->isbreakable = (int *)realloc(cache->isbreakable, cache->numisbreakable*sizeof(int));
+	    }
+	    for (int i = 0 ; i < len ; ++i) {
+		cache->isbreakable[i] = 0;
+	    }
+            if ( cache->numwbrpos > 0 ) {
+            	for (int i = cache->numwbrpos-1; i >= 0; --i) {
+                	cache->isbreakable[cache->wbrpos[i]] = 1;
+		}
+	    }
+            cache->string = string;
+        }
+	return cache->isbreakable[pos];
+    }
+}
diff -uNr kdelibs-3.2.3.org/khtml/rendering/break_lines.h kdelibs-3.2.3/khtml/rendering/break_lines.h
--- kdelibs-3.2.3.org/khtml/rendering/break_lines.h	2004-03-01 00:27:59.000000000 +0900
+++ kdelibs-3.2.3/khtml/rendering/break_lines.h	2004-06-20 14:40:03.000000000 +0900
@@ -116,7 +116,10 @@
         }
     }
     
-    inline bool isBreakable( const QChar *str, const int pos, int /*len*/ )
+    bool isBreakableThai( const QChar *string, const int pos, const int len);
+    void cleanup_thaibreaks();
+
+    inline bool isBreakable( const QChar *str, const int pos, int len )
     {
 	const QChar *c = str+pos;
 	unsigned short ch = c->unicode();
@@ -126,9 +129,8 @@
 	    if ( row == 0x0e ) {
 		// 0e00 - 0e7f == Thai
 		if ( c->cell() < 0x80 ) {
-		    // we don't a have a thai line breaking lib at the moment, allow
-		    // breaks everywhere except directly before punctuation.
-		    return true;
+		    // consult libthai
+		    return isBreakableThai(str, pos, len);
 		} else
 		    return false;
 	    }

diff -uNr kde4libs-4.0.0.orig/kate/document/katedocument.cpp kde4libs-4.0.0/kate/document/katedocument.cpp
--- kde4libs-4.0.0.orig/kate/document/katedocument.cpp	2008-01-21 17:00:06.000000000 +0700
+++ kde4libs-4.0.0/kate/document/katedocument.cpp	2008-01-23 10:59:51.000000000 +0700
@@ -560,6 +560,16 @@
   return l->string();
 }
 
+bool KateDocument::getBreakLine(int line, int col)
+{
+  KateTextLine::Ptr l = m_buffer->plainLine(line);
+
+  if(!l)
+    return 0;
+  
+  return l->isBreakable(col);
+}
+
 bool KateDocument::setText(const QString &s)
 {
   if (!isReadWrite())
@@ -1192,7 +1202,8 @@
       for (z=searchStart; z > 0; z--)
       {
         if (t.at(z).isSpace()) break;
-        if ( ! nw && highlight()->canBreakAt( t.at(z) , l->attribute(z) ) )
+        if (l->isBreakable(z+1)) break;
+	if ( ! nw && highlight()->canBreakAt( t.at(z) , l->attribute(z) ) )
         nw = z;
       }
 
@@ -1238,7 +1249,8 @@
 
       if (removeTrailingSpace) {
         // cu space
-        editRemoveText (line + 1, z - 1, 1);
+        if (!l->isBreakable(z))
+	  editRemoveText (line + 1, z - 1, 1);
       }
     }
   }
diff -uNr kde4libs-4.0.0.orig/kate/document/katedocument.h kde4libs-4.0.0/kate/document/katedocument.h
--- kde4libs-4.0.0.orig/kate/document/katedocument.h	2008-01-21 17:00:06.000000000 +0700
+++ kde4libs-4.0.0/kate/document/katedocument.h	2008-01-23 10:59:51.000000000 +0700
@@ -183,6 +183,7 @@
     virtual QString line(int line) const;
     virtual QChar character(const KTextEditor::Cursor& position) const;
     int lines() const;
+    bool getBreakLine(int line, int col);
     virtual KTextEditor::Cursor documentEnd() const;
     int numVisLines() const;
     int totalCharacters() const;
diff -uNr kde4libs-4.0.0.orig/kate/document/katetextline.cpp kde4libs-4.0.0/kate/document/katetextline.cpp
--- kde4libs-4.0.0.orig/kate/document/katetextline.cpp	2008-01-21 17:00:06.000000000 +0700
+++ kde4libs-4.0.0/kate/document/katetextline.cpp	2008-01-23 11:08:26.000000000 +0700
@@ -28,6 +28,107 @@
 
 #include <QtCore/QRegExp>
 
+//Load Libthai
+#include <QtCore/QTextCodec>
+#include <qlibrary.h>
+#ifndef HAVE_LIBTHAI
+typedef int (*th_brk_def)(const unsigned char*, int[], int);
+static th_brk_def th_brk;
+#else
+#include <thai/thailib.h>
+#include <thai/thbrk.h>
+#endif
+
+//Thai Break
+struct ThaiCache
+{
+    ThaiCache() {
+        string = 0;
+        allocated = 0x400;
+        wbrpos = (int *) malloc(allocated*sizeof(int));
+        numwbrpos = 0;
+        numisbreakable = 0x400;
+        isbreakable = (int *) malloc(numisbreakable*sizeof(int));
+    }
+    ~ThaiCache() {
+        free(wbrpos);
+        free(isbreakable);
+    }
+    const QChar *string;
+    int *wbrpos;
+    int *isbreakable;
+    int allocated;
+    int numwbrpos,numisbreakable;
+};
+static ThaiCache *cache = 0;
+
+void cleanup_thaibreaks()
+{
+    delete cache;
+    cache = 0;
+#ifndef HAVE_LIBTHAI
+    th_brk = 0;
+#endif
+}
+
+bool isbreakWordThai( const QChar *string, const int pos, const int len)
+{
+    static QTextCodec *thaiCodec = QTextCodec::codecForMib(2259);
+
+#ifndef HAVE_LIBTHAI
+    // KLibLoader requires libthai.la which is usually in libthai-dev package or doesn't exist at all
+    // QLibrary::resolve will look for libthai.so.0 directly
+    /* load libthai dynamically */
+    if (!th_brk && thaiCodec) {
+        printf("Try to load libthai dynamically...\n");
+        th_brk = (th_brk_def)QLibrary::resolve("thai", "th_brk");
+        if (!th_brk) {
+        printf("Error, can't load libthai...\n");
+            thaiCodec = 0;
+        }
+    }
+
+    if (!th_brk ) {
+        return NULL;
+    }
+#endif
+
+    if (!cache ) {
+        cache = new ThaiCache;
+#ifndef HAVE_LIBTHAI
+            //cache->library = lib;
+#endif
+    }
+    // build up string of thai chars
+    if ( string != cache->string ) {
+        //fprintf(stderr,"new string found (not in cache), calling libthai\n");
+        QByteArray cstr = thaiCodec->fromUnicode( QString::fromRawData(string,len));
+        //printf("About to call libthai::th_brk with str: %s",cstr.data());
+         cache->numwbrpos = th_brk((const unsigned char*) cstr.data(), cache->wbrpos, cache->allocated);
+        //fprintf(stderr,"libthai returns with value %d\n",cache->numwbrpos);
+        if (cache->numwbrpos > cache->allocated) {
+            cache->allocated = cache->numwbrpos;
+            cache->wbrpos = (int *)realloc(cache->wbrpos, cache->allocated*sizeof(int));
+            cache->numwbrpos = th_brk((const unsigned char*) cstr.data(), cache->wbrpos, cache->allocated);
+        }
+        if ( len > cache->numisbreakable ) {
+            cache->numisbreakable=len;
+            cache->isbreakable = (int *)realloc(cache->isbreakable, cache->numisbreakable*sizeof(int));
+        }
+        for (int i = 0 ; i < len ; ++i) {
+            cache->isbreakable[i] = 0;
+        }
+        if ( cache->numwbrpos > 0 ) {
+            for (int i = cache->numwbrpos-1; i >= 0; --i) {
+                cache->isbreakable[cache->wbrpos[i]] = 1;
+            }
+        }
+        cache->string = string;
+    }
+ 
+    return cache->isbreakable[pos];
+}
+
 KateTextLine::KateTextLine ()
   : m_flags(0)
 {
@@ -49,6 +150,26 @@
     return;
 
   m_text.insert (pos, insText);
+
+  m_breakLine.resize (m_text.size());
+  for (int i = pos; i < pos + insText.length(); i++) {
+    m_breakLine.insert (i, false);
+  }
+
+  int i_pos = pos;
+  while (i_pos != 0 && !m_text[i_pos].isSpace()) {
+    --i_pos;
+  }
+  for (int i = i_pos; i < pos + insText.length(); i++) {
+    if (m_text[i].unicode() >= 0x0e00 && m_text[i].unicode() < 0x0e80) { //0e00 - 0e7f == Thai
+      m_breakLine[i] = isbreakWordThai(m_text.constData(), i, m_text.size());
+    }
+  }
+}
+
+bool KateTextLine::isBreakable (int pos)
+{
+  return m_breakLine[pos];
 }
 
 void KateTextLine::removeText (uint pos, uint delLen)
@@ -69,6 +190,7 @@
     delLen = textLen - pos;
 
   m_text.remove (pos, delLen);
+  m_breakLine.remove (pos, delLen);
 }
 
 void KateTextLine::truncate(int newLen)
diff -uNr kde4libs-4.0.0.orig/kate/document/katetextline.h kde4libs-4.0.0/kate/document/katetextline.h
--- kde4libs-4.0.0.orig/kate/document/katetextline.h	2008-01-21 17:00:06.000000000 +0700
+++ kde4libs-4.0.0/kate/document/katetextline.h	2008-01-23 10:59:51.000000000 +0700
@@ -285,6 +285,12 @@
     void insertText (int pos, const QString& insText);
 
     /**
+     * return breakline attribute m_breakLine
+     * @param pos insert position
+     */    
+    bool isBreakable (int pos);
+
+    /**
      * remove text at given position
      * @param pos start position of remove
      * @param delLen length to remove
@@ -375,6 +381,11 @@
      */
     QVector<int> m_attributesList;
 
+     /**
+     * Attribute for lineBreak value "true" for breakline
+     */
+    QVector<bool> m_breakLine;
+
     /**
      * context stack
      */
diff -uNr kde4libs-4.0.0.orig/kate/view/kateviewinternal.cpp kde4libs-4.0.0/kate/view/kateviewinternal.cpp
--- kde4libs-4.0.0.orig/kate/view/kateviewinternal.cpp	2008-01-21 17:00:06.000000000 +0700
+++ kde4libs-4.0.0/kate/view/kateviewinternal.cpp	2008-01-23 10:59:51.000000000 +0700
@@ -732,7 +732,11 @@
 
 void KateViewInternal::doDelete()
 {
-  m_doc->del( m_view, m_cursor );
+  if ( m_view->config()->persistentSelection() || !m_view->selection() ) {
+    m_view->shiftCursorRight();
+  }
+  m_view->removeSelectedText();
+  return;
 }
 
 void KateViewInternal::doBackspace()
@@ -1024,8 +1028,11 @@
   }
   else if( h->isInWord( m_doc->line( c.line() )[ c.column() - 1 ] ) )
   {
-    while( !c.atEdge( left ) && h->isInWord( m_doc->line( c.line() )[ c.column() - 1 ] ) )
-      --c;
+    if (m_doc->getBreakLine(c.line(),c.column()))
+       --c;
+
+    while( !c.atEdge( left ) && h->isInWord( m_doc->line( c.line() )[ c.column() - 1 ] ) && !m_doc->getBreakLine(c.line(),c.column()))
+       --c;
   }
   else
   {
@@ -1062,7 +1069,9 @@
   }
   else if( h->isInWord( m_doc->line( c.line() )[ c.column() ] ) )
   {
-    while( !c.atEdge( right ) && h->isInWord( m_doc->line( c.line() )[ c.column() ] ) )
+    if (m_doc->getBreakLine(c.line(),c.column()))
+      ++c;
+    while( !c.atEdge( right ) && h->isInWord( m_doc->line( c.line() )[ c.column() ] ) && !m_doc->getBreakLine(c.line(),c.column()) )
       ++c;
   }
   else
@@ -3410,7 +3419,7 @@
       return renderer()->currentFont();
 
     case Qt::ImCursorPosition:
-      return cursorCoordinates(false);
+      return m_displayCursor.column();
 
     case Qt::ImSurroundingText:
       if (KateTextLine::Ptr l = textLine(m_cursor.line()))
